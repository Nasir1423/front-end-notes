<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise 初体验</title>
    <!-- 
        1. Promise 是什么？
            - Promise 是异步编程的一种新解决方案（旧方案是单纯使用回调函数）
                - 异步编程：定时器、fs 模块、ajax、数据库操作等
            - 从语法上说，Promise 是一个构造函数
            从功能上说，Promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值
        2. Promise 的优势
            - 指定回调函数的方式更加灵活
                - 启动异步任务 -> 返回 promise 对象 -> 给 promise 对象绑定回调函数
            - 可以解决回调地狱问题，支持链式调用
                - 回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件
                - 回调地狱的缺点：不便于阅读；不便于异常处理
                - 回调地狱的解决方案：promise 链式调用；async/await
        3. Promise 的基本语法
            - 创建 promise 对象：const p = new Promise(executor)
                - executor 是一个回调函数，其结构为 (resolve, reject) => {}
                - resolve 是一个函数类型的数据
                    - 在 executor 函数体中 “定义成功” 时调用的函数，结构为 value => {}
                    - 该函数会将 promise 对象的状态设置为 “成功”
                - reject 是一个函数类型的数据
                    - 在 executor 函数体中 “定义失败” 时调用的函数，结构为 reason => {}
                    - 该函数会将 promise 对象的状态设置为 “失败”
                - executor 会在 Promise 内部立即 “同步调用”，而异步操作在执行器中执行
            - 处理异步操作的结果：p.then(onResolved, onRejected)
                - onResolved 是一个函数，结构为 value => {}
                - onRejected 是一个函数，结构为 reason => {}
                - 如果 Promise 对象中的结果为 “定义成功” 时，执行 resolve 函数
                - 如果 Promise 对象中的结果为 “定义失败” 时，执行 reject 函数

        本案例实现：点击按钮 1s 后显示是否中奖（中奖概率为 30%）
            - 如果中奖，则弹出 “恭喜中奖，您的幸运号码为 xxx”
            - 如果没中，则弹出 “再接再厉，您的抽奖号码为 xxx”
     -->
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css" rel="stylesheet">
</head>
<div class="container">
    <h2 class="page-header">Promise 初体验</h2>
    <h2 class="btn btn-primary" id="btn">点击抽奖</h2>
    <script>
        // 生成指定范围内的随机数
        function rand(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        const btn = document.querySelector('#btn');
        btn.addEventListener('click', () => {
            // 创建 Promise 对象
            // resolve 和 reject 都是函数类型的数据，分别在 “定义成功” 和 “定义失败” 时调用
            const p = new Promise((resolve, reject) => {
                setTimeout(() => {
                    let randomNumber = rand(1, 100);
                    if (randomNumber <= 30) {
                        resolve(randomNumber);
                    } else {
                        reject(randomNumber);
                    }
                }, 1000);
            });

            // 通过 Promise 原型的 then 方法，实现对异步操作结果的处理
            // 传入两个函数，分别为 resolve 和 reject，对应 “定义成功” 和 “定义失败” 时调用的函数
            p.then((value) => {
                alert(`恭喜中奖，您的幸运号码为 ${value}`);
            }, (reason) => {
                alert(`再接再厉，您的抽奖号码为 ${reason}`);
            });
        });
    </script>
</div>

<body>

</body>

</html>