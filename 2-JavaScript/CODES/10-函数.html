<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数</title>
    <script>
        /*
            1. 什么是函数（Function）？函数是一个存储代码的对象，具有其他对象所有的功能，并且可以在需要时调用这些代码

            2. 函数的定义方式
                - 函数声明
                    function fun_name([参数]) {
                        语句
                    }
                - 函数表达式
                    const 变量 = function([参数]) {
                        语句
                    }
                - 箭头函数
                    const 变量 = ([参数]) => {
                        语句
                    }   
                - 注解
                    > 函数表达式和箭头函数都是匿名函数，返回一个函数对象给对应的变量，然后通过该变量调用函数
                    > 使用 const 关键字声明存储函数对象的变量，是为了避免变量的重复赋值
                    > 箭头函数的函数体如果只有一行语句，则可以省略花括号
                    > 箭头函数有且仅有一个参数，则可以省略括号
            
            3. 函数的调用：函数对象()
                - 对于函数声明， fun_name 就是一个函数对象
                - 对于匿名函数，变量就是一个函数对象
            
            4. 函数的检查：使用 typeof 运算符检查函数对象时会返回 function

            5. 实参与形参
                - 形式参数（形参）：定义函数时，在函数中指定的数量不等的参数，以逗号分隔，相当于在函数内部声明了变量但是没赋值
                - 实际参数（实参）：调用函数时，在函数的 () 中传递数量不等的参数，以逗号分隔
                - 函数调用时传递的实参会赋值给函数中对应的形参
                    - 实参数量 = 形参数量：对应的实参赋值给对应的形参
                    - 实参数量 > 形参数量：多余实参不予使用
                    - 实参数量 < 行参数量：多余形参值为 undefined
                - JS 不会检查函数参数的数据类型，从而减少报错，但是我们在实际使用中应该手动进行类型判断，从而确保代码实现符合预期；
                如希望参数是数值类型时，可以先将传入的实参转换为数值类型，再使用 isNaN 函数进行合法性判断

            6. 参数的默认值：定义参数时，可以为其指定默认值，在没有传入对应的实参时生效
                - 语法：形参名=默认值

            7. 参数类型
                - 对象作为函数参数：形参的修改会影响到实参
                - 对象作为函数形参的默认值：每次调用函数，都会通过默认值创建一个新的对象
                - 函数也可以作为函数参数

            8. 函数的返回值：函数体中，可以通过 return 关键在来指定函数的返回值
                - 任何值（包括对象和函数等）都可以作为函数的返回值
                - return 后如果不跟任何值，则相当于返回 undefined
                - 如果不使用 return 关键字，则函数的返回值仍然是 undefined
                - return 关键字有使函数立即结束的作用
                - 箭头函数的返回值（如果函数只有返回值这一条语句，则可以省略花括号和关键字；但是如果返回的是一个对象字面量，则需要
                用括号括起，避免对象字面量的花括号和函数体的花括号产生混淆）
                    > (a, b) => a + b
                    > () => ({name: "Tom"})
                
            9. 全局作用域和局部作用域
                - 作用域（scope）：指的是一个变量的可见区域，分为全局作用域和局部作用域
                - 全局作用域：在网页运行时创建，网页关闭时销毁；所有“直接”编写在 script 标签中的变量都位于全局作用域中；全局作用
                域中的变量是全局变量，可以在任意位置访问
                - 局部作用域
                    > 块作用域：在代码执行时创建，执行完毕后销毁；块作用域中的变量是局部变量，只能在块内部访问，外部无法访问
                    > 函数作用域：在函数调用时创建，调用完毕后销毁；函数的每次调用都会产生一个全新的函数作用域；函数作用域中定义的
                    变量是局部变量，只能在函数内部访问，外部无法访问
            
            10. 作用域链：当我们要使用一个变量时，JS 解释器会优先在当前作用域中寻找变量，找到则直接使用，没找到就去上一层作用域中
            去寻找，...，如果一直找到全局作用域都没找到，则会报错 xxx is not defined

            11. 对象的函数 —— 方法（method）
                - 当一个对象的属性指向一个函数，此时就称这个函数是该对象的方法，调用该函数称之为调用对象的方法

            12. window 对象：浏览器为我们提供了一个可以直接访问的 window 对象，表示浏览器窗口，通过该对象可以对浏览器窗口进行各种
            操作；同时 window 对象还负责存储 JS 中的内置对象和浏览器中的宿主对象
                - window 对象的属性可以通过 window 对象访问，也可以直接访问，如 window.console.log("Hello")
                - 函数可以认为是 window 对象的方法，如 window.alert("Hello")

            13. let、var、function、window 声明区别
                - var 声明变量和 let 声明变量的区别是：var 声明的变量不具有块作用域
                - 全局作用域中使用 var 声明的变量，都会作为 window 对象的属性保存（var a = 10 等价于 window.a = 10）
                - 全局作用域中使用 function 声明的函数，都会作为 window 对象的方法保存
                - 全局作用域中使用 let 声明的变量，不会存储在 window 对象中，而是存储在一个特定的地方
                - 如果 window.a 和 let a 两种方式声明同名变量，则在后续代码中，访问的是 let 声明的变量
                - var 虽然没有块作用域，但是有函数作用域
                - 在局部作用域中，如果没有使用 var 或 let 声明变量，直接使用 a = 10 这样的方式，则变量会自动成为 window 对象的
                属性，也就是全局变量（不建议使用）

            14. 提升
                - 变量的提升
                    > 使用 var 声明的变量，会在所有代码开始执行前被声明（假设 19 行：var a = 1，那么 JS 解释器会将 var a 提升到
                    所有代码的最前边，19 行的代码此时就相当于一个简单赋值 a = 1），因此我们可以在变量实际声明位置前就访问该变量
                    > 使用 let 声明的变量，也存在提升，但是 JS 解释器禁止在代码中变量声明的实际位置前访问该变量
                - 函数的提升：使用函数声明（方式一）创建的函数，会在所有代码执行前被创建，因此我们可以在函数声明前调用函数
                - 函数中变量的提升：函数中声明的变量，也会在函数所有代码开始执行前提升到函数最开始的位置（类似的 let 声明的变量不
                能提前访问；var 声明的变量可以提前访问）
                - 变量的提升只涉及变量的声明；函数的提升包含其声明和函数体中的代码
                - 提升的意义？为变量和函数预先分配内存空间，避免因为频繁内存分配降低代码效率
                - 注：直接通过 a = 10，相当于 window = 10 的方式，此时变量不存在提升

            15. 代码编写规范：实际开发中减少在全局作用域中编写代码，而尽量在局部作用域中编写；可以使用 {} 来创建块作用域

            16. 立即执行函数（IIFE）
                - 特点
                    > IIFE 是匿名函数，并且只会调用一次
                    > IIFE 不会被提升
                    > IIFE 可以用于创建一个一次性的函数作用域，从而避免变量的冲突问题
                - 语法：类似函数表达式的调用，但是整体外边需要括起，并且必须以 ; 结束
                    (function([参数]){
                        语句
                    }());

            17. 函数中的 this：函数在执行时，JS 解释器每次都会传进一个隐含的参数 this，this 指向一个对象
                - 对于函数声明和函数表达式创建的函数，this 指向的对象会根据函数调用方式的不同而不同
                    > 以函数形式调用，如 fun_name()，此时 this 指向的是 window 对象
                    > 以方法形式调用，如 obj_name.method_name()，此时 this 指向的是调用该方法的对象 obj_name
                - 对于箭头函数，this 由外层作用域决定，与其调用方式无关，如：箭头函数的外层作用域是全局作用域，则 this 指向 
                window 对象；箭头函数的外层作用域是对象 obj_name，则 this 指向 obj_name 对象


            18. 箭头函数语法总结
                - 函数体只有返回值语句
                    > 无参：() => 返回值
                    > 单参：a => 返回值
                    > 多参：(a, b, c, ...) => 返回值
                    > 返回值为对象：() => ({...})
                - 函数体有多行语句
                    () => {
                        语句
                        return 返回值
                    }

            19 严格模式：JS 运行代码的模式有两种，正常模式和严格模式
                - 正常模式：默认情况下代码都运行在正常模式中
                    > 语法检查不严格，能不报错就不报错
                    > 代码运行性能较差
                - 严格模式：使用 "use strict" 可以在当前作用域下开启严格模式
                    > 语法检查变严格，禁止了一些语法，更容易报错
                    > 代码运行性能提升
                - 实际开发中推荐使用严格模式，一方面避免产生一些隐藏问题，另一方面可以提升代码的运行性能
        */

        "use strict"

        // 8 函数的返回值

        // function sum1(a, b) {
        //     return a + b
        // }

        // const sum2 = function (a, b) {
        //     return a + b
        // }

        // const sum3 = (a, b) => a + b

        // let a = 12
        // let b = 13

        // console.log(`${a}+${b}=${sum2(a, b)}`)

        // 10 作用域链

        // let variable = 15 // 1

        // function f1() {
        //     let variable = 16 // 2

        //     function f2() {
        //         let variable = 17 // 3
        //         console.log(variable) // 寻找顺序 3 → 2 → 1，找到则使用，找不到则继续向外找
        //     }
        // }

        // 11 对象的函数 —— 方法

        // let person = new Object()

        // person.name = "yiTu"
        // person.gender = "Male"
        // person.sayHello = () => console.log(`Hello, I'm ${person.name}`)

        // person.sayHello()

        // 14 提升 —— 代码分析

        // // [1] 的声明 var a 和 [2] 的声明及代码发生了提升
        // // 在 JavaScript 中，变量声明会被提升（hoisted），但是函数声明会被提升到变量声明之前
        // // 因此这里打印的函数 [2]
        // console.log(a) 

        // var a = 1 // [1]；实际执行到这里，相当于 a = 1 这个赋值语句，此时 a 覆盖了 a()

        // // 因为 [1] 相当于 a = 1，覆盖了 a()
        // // 因此这里打印的 1
        // console.log(a)

        // function a() { // [2]；实际执行到这里会直接跳过，因为已经提升了
        //     alert(2)
        // }

        // // 因为 [2] 跳过了，因此这里 a 不变，打印结果仍为 1
        // console.log(a)

        // var a = 3 // [3]；实际执行到这里，相当于 a = 3 这个赋值语句

        // // 因为 [3] 相当于重新赋值，因此这里 a 打印为 3
        // console.log(a)

        // var a = function() { //[4]；实际执行到这里，相当于 a = 函数对象，即一个赋值语句
        //     alert(4)
        // }

        // // 因为 [4] 相当于重新赋值，因此这里的 a 打印为函数 [4]
        // console.log(a)

        // var a // [5]；实际执行到这里跳过，因为 var a 早都因为 [1] 提升了变量 a 的声明

        // // 因为 [5] 跳过了，因此这里 a 不变，打印结果仍为函数 [4]
        // console.log(a);

        // 16 立即执行函数
        // (function () {
        //     console.log("hello world")
        // }());

        // 17 函数中的 this

        // const stu1 = {
        //     name: "jack",
        //     gender: "male",
        //     height: 178,
        //     weight: 78,
        //     performance: "B",
        //     details: function () {
        //         console.log(`My name is ${this.name}, and I'm ${this.height} cm tall, ${this.weight} kg weight, Performance grade is ${this.performance}`);
        //     }
        // }

        // const stu2 = {
        //     name: "Jerry",
        //     gender: "female",
        //     height: 157,
        //     weight: 48,
        //     performance: "A",
        //     details() {
        //         console.log(`My name is ${this.name}, and I'm ${this.height} cm tall, ${this.weight} kg weight, Performance grade is ${this.performance}`);
        //     }
        // }

        // stu1.details()

        // stu2.details()


    </script>
</head>

<body>

</body>

</html>