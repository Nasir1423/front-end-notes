# 内容导航

| 类别 |                             导航                             |
| :--: | :----------------------------------------------------------: |
| 网络 |                [OSI 七层模型](#OSI 七层模型)                 |
|      |             [TCP/IP 四层模型](#TCP/IP 四层模型)              |
|      |           [TCP 和 UDP 的区别](#TCP 和 UDP 的区别)            |
| 架构 | [如何封装健壮性强的 react 组件](#如何封装健壮性强的 react 组件) |

### OSI 七层模型

OSI 将计算机网络分了**七层**，每一层**抽象**底层的内容，并遵守一定**规则**。基于OSI 网络模型，网络中的**节点/物理设备**得以进行通信。从顶层到底层，OSI 共规定了以下七层，

1. **应用层** Application Layer：支持**用户程序**使用的服务。应用层包含若干协议：**文件传输协议** FTP、**安全壳协议** SSH、**简单邮件传输协议** SMTP、**因特网消息访问协议** IMAP、**域名服务** DNS、**超文本传输协议** HTTP
2. **表示层** Presentation Layer：**数据格式化**（如字符编码控制）、**数据加密**（SSL/TLS）。
3. **会话层** Session Layer：**建立、维持和终止**两个用户程序之间的**连接**。会话层以上的网络层关注：**如何与用户应用程序建立连接**，以及**如何向用户展示数据**。
4. **传输层** Transport Layer：通过 TCP 或 UDP 将数据发送给设备的特定端口，**建立数据通信**。传输层有两个重要协议，**传输控制协议** TCP 和**用户数据报协议** UDP。
   - 传输控制协议 TCP：**面向连接**的协议；优先保证**数据质量**而不是传输速度
   - 用户数据报协议 UDP：**无连接**的协议；优先保证**传输速度**而不是传输质量
5. **网络层** Network Layer：通过**路由器**在网络间进行通信。
6. **数据链路层** Data Link Layer：定义**数据的传输格式**，进行**线路规划与流量控制**，进行**错误监测与校正。**
7. **物理层** Physical Layer：通过**网线、电缆**等方式将设备**物理连接。**

### TCP/IP 四层模型

TCP/IP **四层**模型可以看作是对 OSI 七层模型的**简化**，从顶层到底层，具体划分如下，

1. **应用层**：对应 OSI 的应用层、表示层、会话层。
2. **传输层**：对应 OSI 的传输层，通过 TCP/IP 协议实现**端口到端口的通信**（即两台主机间进程通信）
3. **网络层**：对应 OSI 的网络层，建立**主机间的通信**。
4. **数据链路层**：对应 OSI 的数据链路层、物理层，通过**物理手段连接设备**。

### TCP 和 UDP 的区别

1. TCP（Transmission Control Protocol，传输控制协议）是基于**连接**的，在传输数据时**会建立接收端和发送端之间的连接**，并在传输过程中始终保持这种连接。

   - TCP 在传输数据时会**检查错误**，以**确保发送的数据完整到达目的地**。
   - TCP 会根据接收端的容量进行**优化和调整传输数据的速度**。
   - TCP 会确**认数据已到达目的地**，如果第一次传输失败，会**尝试重新传输**。

2. UDP（User Datagram Protocol，用户数据报协议）是**无连接**的，在传输数据时**不会在双方之间建立事先的连接**。

   - UDP 以**较小负担**发送给数据包，从而**减少端到端的延迟**。
   - 传输过程中数据包丢失数据包，UDP 仍会传送数据，即**数据包的丢失不会中断整个传输**。
   - UDP 可以通过广播和多播功能，**同时发送数据给多个接收端**。
   - UDP 比 TCP 更**快速、高效**。

3. TCP 和 UDP 都是位于**传输层**的通信协议，其区别如下，

   |                区别                |   TCP    |  UDP   |
   | :--------------------------------: | :------: | :----: |
   | 可靠性（按顺序、完整性、错误检测） |    高    |   低   |
   |               连接性               | 面向连接 | 无连接 |
   |                速度                |   较低   |   高   |
   |                ...                 |   ...    |  ...   |

4. TCP 和 UDP 在应用层协议的使用场景

   |         TCP         |        UDP         |
   | :-----------------: | :----------------: |
   |    SMTP 电子邮件    |    DNS 域名转换    |
   | TELNET 远程终端接入 |   TFTP 文件传输    |
   |     HTTP 万维网     |   SNMP 网络管理    |
   |    FTP 文件传输     | NFS 远程文件服务器 |

### 如何封装健壮性强的 react 组件

1. 特征：一个好的组件应该具有 ①**高内聚、低耦合** ②**隐藏内部结构** ③**职责单一** 这些特点。
   - 所谓的**高内聚**，就是**将逻辑紧密相关的内容放在一个组件中**；而**低耦合**，就是**将不同组件之间的依赖关系尽量弱化**。
   - 组件的**低耦合**有利于**修改、替换、复用、单元测试**。
   - **隐藏内部结构**，就是要求**仅通过一组 `props` 来控制组件行为**，这也**有利于减少组件对其他组件的依赖**。
   - **职责单一**，就是要求**一个组件只负责一件事情**，这有利于组件的**维护和复用**。

2. 设计：封装一个组件需要思考 ①**这个组件是干什么的？**②**这个组件应该至少需要知道哪些信息？**③**这个组件会反馈什么内容？**，相较于实现需求，更重要的是对需求的抽象。
3. 行为：父组件通过 `props` 的方式**向封装好的子组件进行通信**，可以使用 `prop-types` 库或 TypeScript 进行**参数验证**，检查传入组件的参数是否合法（数据类型、是否必传等）。

#### 参考：[可靠组件的七个属性（reliable react component）](#https://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/)

##### 1. 单一职责 single responsibility

1. 当一个组件**只有一个改变的理由**时（only one reason to change），该组件就是**单一职责**的。所谓单一职责，就是指**一个组件只负责一项功能的实现**。
2. 单一职责会**约束组件的大小**，同时一个组件只负责一项功能的实现也有利于组件的**编写、修改、复用和测试**。

---

1. 如果你的组件负责多种功能的实现，那么你就要**根据单一职责将其拆分为若干组件**，每个组件只负责一项功能的实现。
2. 如果你的组件负责多种功能的实现，那么可以说这个组件**有许多改变的理由**（many reasons to change），此时该组件**一项功能的修改可能会不小心影响到该组件实现的其他功能**。或者说，多种职责的组件是脆弱的，其副作用是无法预测、难以控制的。

---

**最差**的多种职责的组件实现称之为**上帝组件**（God Component），①功能上，上帝组件倾向于在一个组件中实现所有功能 ②命名上，上帝组件可能会以 `<Application>`、`<Manager>`、`<BigContainer>` 等作为组件名 ③代码量上，上帝组件会包含超过 500 行代码。

---

1. 按职责拆分组件有助于代码结构化，但**不一定能保证每个组件真正遵循了单一职责原则**。这句话的意思是不能仅仅为了拆分而拆分，而是要确保每个组件只承担单一职责。为了达到这一目标，一个比较好的实践是**高阶组件**（HOC，higher order components），所谓高阶组件，就是一个函数，其接收一个组件参数，并返回一个新组件。

2. 高阶组件的两个常用技巧是**属性代理**（props proxy）和**渲染劫持**（render highjacking）。

   - 所谓属性代理就是通过**修改或添加** `props` 来为组件提供额外的功能，换句话说属性代理允许你**通过 HOC 在不修改原组件的情况下，改变其 `props`，从而添加额外功能**。

     ```js
     /* 高阶组件 withNewFunctionality 的作用是
     	- 修改其组件参数 WrappedComponent 的 props 属性，之后再
     	- 渲染组件 WrappedComponent */
     const withNewFunctionality = (WrappedComponent) => (props) => {
       const newProp = 'Value';
       const propsProxy = {
         ...props,
         // Alter existing prop:
         ownProp: props.ownProp + ' was modified',
         // Add new prop:
         newProp,
       };
     
       return <WrappedComponent {...propsProxy} />;
     };
     
     ```

   - 所谓渲染劫持就是通过**劫持组件的渲染机制**（class 组件的 `render` 方法或 function 组件的返回值）来改变包裹组件所渲染的元素或内容，换句话说渲染劫持允许你在不修改原始组件的情况下**注入额外的内容、改变组件的渲染方式或包装渲染结果**。

---

通过 HOC 的 props proxy 实现组件单一职责的示例如下，

1. **不符合**单一职责的组件设计样例

   ```js
   /* PersistentForm 组件不符合单一职责 (1)管理表单字段 (2)保存 input value 到存储 */
   import { useState, useEffect } from "react";
   
   function PersistentForm() {
     const [inputValue, setInputValue] = useState("");
   
     useEffect(() => {
       setInputValue(localStorage.getItem("inputValue") || "");
     }, []);
   
     const handleChange = (event) => {
       setInputValue(event.target.value);
     };
   
     const handleClick = () => {
       localStorage.setItem("inputValue", inputValue);
     };
   
     return (
       <div className="persistent-form">
         <input type="text" value={inputValue} onChange={handleChange} />
         <button onClick={handleClick}>Save to storage</button>
       </div>
     );
   }
   
   export default PersistentForm;
   ```

2. 修改后，**符合**单一职责的组件设计样例

   ```js
   /* withPersistence 组件符合单一职责：持久化存储
     - withPersistence 可以接收两级参数，即 withPersistence(storageKey, storage)(WrappedComponent)，其返回值是一个组件，接收 props 参数
     - 通过这种设计，提高了组件的复用率，不仅可以指定要劫持的 props，同时也可以指定 props 的存储和获取方式 */
   import { useState, useEffect } from 'react';
   
   const withPersistence = (storageKey, storage) => (WrappedComponent) => (props) => {
     const [initialValue, setInitialValue] = useState("");
   
     useEffect(() => {
       setInitialValue(storage.getItem(storageKey) || "");
     }, [storageKey]);
   
     const saveValue = (value) => {
       storage.setItem(storageKey, value);
     };
   
     return (
       <WrappedComponent
         initialValue={initialValue}
         saveValue={saveValue}
         {...props}
       />
     );
   };
   ```

##### 2. 封装 encapsulate



### Http1.0、Http1.1、Http2.0 的区别

### 如何实现事件委托

### em/px/rem/vh/vw 的区别

### Cookie、LocalStorage、SessionStorage、IndexedDB

### generator

### https 握手

### 浏览器页面加载慢的解决方式

> 懒加载、react api、script 异步加载、tree shaking；
>
> 思考如何从网络的角度分析

### 跨域及其解决方式

### 预检请求及其发送时机

### react fiber

### react diff 算法的伪代码

### 获取 DOM 是否会触发页面重排

### 如果交给你一个任务的时限超过你可以完成的时间，你会怎么做







# Navigator

|     分类     |                            八股文                            |
| :----------: | :----------------------------------------------------------: |
| 前端八股合集 |        [es6 新特性（ES2015）](#es6 新特性（ES2015）)         |
|              |   [输入 url 到渲染页面的过程](#输入 url 到渲染页面的过程)    |
|              | [HTTP 和 HTTPS 之间的区别是什么？](#HTTP 和 HTTPS 之间的区别是什么？) |
|              |         [Vue2 和 Vue3 的区别](#Vue2 和 Vue3 的区别)          |
|              |        [react 性能优化的方法](#react 性能优化的方法)         |
|              |          [怎么减少回流与重绘](#怎么减少回流与重绘)           |
| 美团一面八股 |      [Promise 的使用，优缺点](#Promise 的使用，优缺点)       |
|              | [浏览器端的事件循环机制，常见的宏任务与微任务，代码输出推测](#浏览器端的事件循环机制，常见的宏任务与微任务，代码输出推测) |
|              |        [如何判断数组数据结构](#如何判断数组数据结构)         |
|              |             [http 常见状态码](#http 常见状态码)              |
|              |            [浏览器的缓存机制](#浏览器的缓存机制)             |
|              | [javascript 是否会阻塞页面渲染](#javascript 是否会阻塞页面渲染) |
| 美团二面八股 | [Node.js 和浏览器 JavaScript 的区别](#Node.js 和浏览器 JavaScript 的区别) |
|              | [行内元素、行内块元素、块级元素的区别](#行内元素、行内块元素、块级元素的区别) |
|              |                                                              |



# 前端八股合集

## es6 新特性（ES2015）

1. `let` 和 `const` 关键字
2. 模板字符串

3. 箭头函数

4. 默认参数、可选参数（又叫其余参数）

   ```js
   const func1 = (message = 'hello') => { /**/ } // 参数默认值
   const func2 = (...rest) => { /**/ } // 可选参数，rest 参数是一个数组
   ```

5. 解构赋值（对象、数组）

6. 展开运算符

7. 类，通过 `class` 关键字定义

8. 模块化，通过 `import` 和 `export` 实现

9. `Promise`

10. `set`、`weakSet`、`map`、`weakMap`

## 输入 url 到渲染页面的过程

Step1. 浏览器查找当前 URL 是否存在**缓存**，并比较缓存是否过期

> 这里的缓存机制包括**强制缓存**和**协商缓存**
>
> **强制缓存**：当浏览器向服务器发送请求时，服务器返回资源的同时，会使用 `Expires` 或 `Cache-Control` 响应头来控制是否缓存对应的资源。
>
> **协商缓存**：当浏览器请求强制缓存中的缓存数据时，如果存在缓存数据及其标识，但缓存结果失效，此时浏览器无法确定该缓存数据是否仍然有效。在这种情况下，浏览器会携带对应的资源标识发送 HTTP 请求，以确认缓存的数据是否与服务器上的数据一致。如果数据一致，服务器会返回 **304** 状态码，告诉浏览器可以继续使用缓存中的数据；如果数据不一致，服务器会返回 200 状态码，并提供最新的数据。`Last-Modified` / `Etag` 响应头和 `If-Modified-Since` / `If-None-Match` 请求头用于控制协商缓存。 

Step2. **DNS 解析** URL 对应的 IP

Step3. 根据 IP 建立 TCP 连接 —— **三次握手**

> 三次握手的大致流程为
>
> 1. 客户端发送 syn 包，等待服务器确认。
> 2. 服务器收到 syn 包，同时发送 syn + ack 包。
> 3. 客户端收到 syn + ack 包，向服务器发送 ack 包。
>
> 发送完毕后，客户端和服务端进入 established 状态，完成三次握手。

Step4. **发送 HTTP 请求**

Step5. 服务器处理请求，并**发送 HTTP 响应**

Step6. 浏览器**解析响应报文**并**渲染页面**

> 解析报文渲染页面的大致流程为
>
> 1. HTML -> DOM 树
> 2. CSS -> CSSOM 树
> 3. DOM 树 + CSSOM 树 -> Render 树
> 4. 浏览器开始渲染并绘制页面（这里涉及到回流重绘两个概念：回流涉及到重新渲染，重绘涉及到样式的修改）

Step7. 关闭 TCP 连接 —— **四次挥手**

> 四次挥手的大致流程为
>
> 1. 客户端发送 fin 包，表示客户端不再发送数据，但可以接收数据
> 2. 服务器收到 fin 包，发送 ack 包及序号，此时服务器处于半关闭状态
> 3. 服务器发送 fin 包，表示关闭服务器到客户端的数据发送
> 4. 客户端收到 fin 包，发送 ack 包并确认序号
>
> 经过一段时间后，客户端进入 closed 状态，服务端收到客户端的确认后立即进入 closed 状态并结束 TCP 连接。

## HTTP 和 HTTPS 之间的区别是什么？

https://www.cnblogs.com/wzh2010/p/18115794

## Vue2 和 Vue3 的区别

## react 性能优化的方法

1. 使用 React.Memo 来缓存组件
2. 使用 useMemo 缓存大量的计算
3. 使用 React.Fragment 避免添加额外的 DOM
4. 组件的懒加载

## 怎么减少回流与重绘

1. 回流 reflow：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染。
2. 重绘 repaint：元素样式的改变（但宽高、大小、位置等不变）。
3. 回流 Vs. 重绘
   - 重绘不是很消耗性能，但是回流很消耗性能
   - 回流一定触发重绘，但重绘不一定会触发回流
4. 减少回流或重绘的方式
   - **放弃手动操作 DOM**，使用 vue 或 react 等框架，以数据驱动视图
   - **批量修改 DOM**，减少回流重绘的次数
   - **DOM 脱离文档流**再进行处理
   - **合并对 DOM 样式的修改**，采用 css class 来修改

